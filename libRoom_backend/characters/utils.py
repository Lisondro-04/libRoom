import json
import os
import re
import uuid
from pathlib import Path
from typing import List, Dict, Tuple

from django.conf import settings

# --------------------------------------------------------------------------- #
# ───────── Helpers to locate the active writing project ──────────────────── #
# --------------------------------------------------------------------------- #

PROJECT_JSON = Path(settings.BASE_DIR) / "project.json"


def _project_root() -> Path:
    """
    Reads project.json (generated by the *project* app) and returns
    the absolute path to the current project folder.
    Example structure inside project.json
        {"project_root": "/absolute/path/to/my_novel"}
    """
    with PROJECT_JSON.open(encoding="utf‑8") as fh:
        cfg = json.load(fh)

    return Path(cfg["project_root"]).resolve()


def _characters_dir() -> Path:
    cdir = _project_root() / "characters"
    cdir.mkdir(parents=True, exist_ok=True)
    return cdir


# --------------------------------------------------------------------------- #
# ───────── Persistent index: <project>/characters/character_list.json ────── #
# --------------------------------------------------------------------------- #

INDEX_FILE = _characters_dir() / "character_list.json"


def _load_index() -> List[Dict]:
    if not INDEX_FILE.exists():
        return []
    with INDEX_FILE.open(encoding="utf‑8") as fh:
        return json.load(fh)


def _save_index(index: List[Dict]) -> None:
    with INDEX_FILE.open("w", encoding="utf‑8") as fh:
        json.dump(index, fh, indent=2, ensure_ascii=False)


def _generate_id() -> str:
    return f"char-{uuid.uuid4().hex[:6]}"


# --------------------------------------------------------------------------- #
# ───────── Markdown helpers ──────────────────────────────────────────────── #
# --------------------------------------------------------------------------- #

_SECTION_RE = re.compile(r"^(##\s+(?P<title>.+?)\s*\n)(?P<body>.*?)(?=^##|\Z)", re.M | re.S)


def write_markdown_skeleton(char_path: Path, name: str, char_type: str) -> None:
    """Creates a minimal MD skeleton so the editor always has sections to patch."""
    skeleton = f"""# {name}

**Type:** {char_type}

## Background
_(Describe the character’s past)_

## Personality
_(Key traits, quirks, fears…)_

## Appearance
_(Hair, eyes, clothes, etc.)_
"""
    char_path.write_text(skeleton, encoding="utf‑8")


def replace_section(md: str, section: str, new_body: str) -> str:
    """
    Replace the body of a '## section' with `new_body`, keeping the heading.
    If section does not exist, it is appended to the end.
    """
    found = False
    parts: List[Tuple[str, str, str]] = []  # (heading, title, body)

    for match in _SECTION_RE.finditer(md):
        heading, title, body = match.group(1), match["title"], match["body"]
        if title.strip().lower() == section.lower():
            found = True
            body = "\n" + new_body.rstrip() + "\n"
        parts.append((heading, title, body))

    if not found:
        parts.append((f"## {section}\n", section, "\n" + new_body.rstrip() + "\n"))

    # rebuild
    return "".join(h + b for h, _, b in parts)
